<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rocketseat - Ignite - ReactJS - Projeto 02 - Anotações</title>
  </head>
  <body>
    <h1>Rocketseat - Ignite - ReactJS - Projeto 02 - Anotações</h1>

    <h2>Estrutura da aplicação</h2>

    <h3>Criação do projeto</h3>
    <p>Criando o projeto usando vite e limpando as configurações padrões.</p>

    <h3>Styled Components</h3>
    <p>
      Entendendo o uso do styled-components no react para estilizar nossos
      componentes. Em vez de utilizarmos class name usamos esta biblioteca para
      que as propriedades passadas pelos pais possam afetar o estilo dos filhos.
      Usamos no exemplo a cor de fundo dos botões.
    </p>

    <h3>Configurando temas</h3>
    <p>
      Podemos usar o gerenciador de temas do styled-components para facilitar a
      aplicação de css e temas específicos através de arquivos na pasta themes
      dentro de styles. Para navegarmos entre os temas basta trocarmos a seleção
      do ThemeProvider em torno dos nossos componentes. Esse gerenciamento pode
      ser feito via um estado que é alterado por um botão específico.
    </p>

    <h3>Tipagem de temas</h3>
    <p>
      Usando o arquivo default.d.ts criamos uma nova interface a partir da
      interface DefaultTheme já existente dentro do styled-components
      adicionando as propriedades que precisamos usar conforme temas criados.
      Com isso conseguimos integrar os temas dentro do nosso projeto fazendo as
      propriedades acessíveis nos arquivos de estilo.
    </p>

    <h3>Estilos globais</h3>
    <p>
      Podemos criar estilos globais usando o styled-components através da função
      createGlobalStyle e inserindo o componete criado chamado GlobalStyles
      dentro do ThemeProvider.
    </p>

    <h3>Cores e Fontes</h3>
    <p>
      Inserindo as fontes via google fonts e cores padrões da aplicação e
      inciando a estilização do tema e dos componentes.
    </p>

    <h3>Configurando ESLint</h3>
    <p>
      EcmaScriptLinting - serve para padronizar o projeto conforme configuração
      do criador do mesmo, substituindo por exemplo aspás duplas por simples e
      vice versa.
    </p>

    <h2>Páginas e rotas</h2>

    <h3>React Router DOM</h3>
    <p>
      Instalando o react-router-dom para estabelecermos a rota dos componentes e
      configurando a aplicação, removendo os botões e acrescentando as páginas
      de Home e History para iniciar o trabalho com rotar através do componente
      Router e do context provider BrowserRouter.
    </p>

    <h3>Layout de rotas</h3>
    <p>
      Acrescentando o header padrão da aplicação via layout e redefinindo as
      rotas para que seja carregado o DefaultLayout em todas as páginas. No
      arquivo de rotas a rota final será a sompatória de todas as rotas
      precedentes, com exemplo admin e admin -> products.
    </p>

    <h3>Header & Layout</h3>
    <p>
      Configurando o layout que é basicamente o fundo preto por volta da
      aplicação via DefaultLayout e também construindo o Header com o logo e
      links necessários. Aplicamos estilização no Header via componente ts
      usando bordas em cima e em baixo para centraliza-lo e também a tag active
      gerada pelo NavLink do react-router-dom para indicar qual página está
      ativa.
    </p>

    <h3>Página: Home</h3>
    <p>
      Adicionando estrutura e estilização na página home usando styled
      components.
    </p>

    <h3>Finalização da Home</h3>
    <p>Finalizando a estilização do formulário, timer e botão.</p>

    <h3>Aprimorando os inputs</h3>
    <p>
      Adicionando configurações no estilo dos inputs como list de sugestões,
      eliminação de features padrão do brownser, etc.
    </p>

    <h3>Página: History</h3>
    <p>
      Adicionando a estrutura básica via tabela da página History e configurando
      o estilo básico.
    </p>

    <h3>Componente: Status</h3>
    <p>
      Desenvolvendo o componente para mostrar o status das tarefas e usando as
      propriedades dos styled components para fazer a mudança de cores quando
      necessário. Usamos uma constante criada para transformarmos os inputs nas
      cores padrão do tema.
    </p>

    <h2>Formulários</h2>

    <h3>Controlled vs Uncontrolled</h3>
    <p>
      Podemos trabalhar com formulários de 2 formas: controlled - o valor do
      input é controlado em tempo real via estado, isso facilita o acesso as
      informações quando fazemos o submit e também para alterar visualmente a
      interface baseado nesse estado; uncontrolled - atualiza o valor do estado
      somente no momento que precisarmos utilizar ela, menos tempo de
      processamento. Controlled para formulários simples, uncontrolled para
      formulários complexos.
    </p>

    <h3>React Hook Form</h3>
    <p>
      Biblioteca para trabalhar com formulários em react usando o melhor dos
      dois mundos (controlled e uncontrolled). Usando o register do
      react-hook-form podemos acoplar em nossos inputs as propriedades para
      validação, controle, etc do conteúdo do input. Para usarmos o handleSubmit
      passamos como parâmetro dela a nossa função handle no formulário. Ainda,
      podemos observar os inputs em tempo real por meio da função watch. Criamos
      uma variável auxiliar para o disabled do botao para facilitar a leitura e
      manutenção do código.
    </p>

    <h3>Validando Formulários</h3>
    <p>
      Biblioteca para fazer validação do formulário, zod. Podemos importar todas
      as funções da biblioteca via * e dar um nome específico quando não existe
      um export default na biblioteca. Para validarmos precisamos passar um
      Schema dos dados via zod object no caso, pois estamos validando um objeto.
      Podemos definir menssagens personalizadas para cada validação.
    </p>

    <h3>TypeScript no formulário</h3>
    <p>
      Podemos definir a interface para o data de forma padrão do TS e usar essa
      definição na validação do formulário para passarmos valores padrões para
      os dados. A integração do zod com o TS permite extrair a tipagem do
      formulário de dentro do Schema de validação usando o infer.
    </p>

    <h3>Resetando formulário</h3>
    <p>
      Podemos trazer da biblioteca zod pela função zodResolver a função reset,
      ela irá resetar o formulário para os valores padrões que setamos como
      defaultValues, basta incluirmos em nossa função handle de submit do
      formulário.
    </p>

    <h2>Funcionalidades da aplicação</h2>

    <h3>Iniciando novo ciclo</h3>
    <p>
      Criamos uma interface de ciclo e um estado de array de ciclos para
      salvarmos as informações inseridas pelos usuários. Para o id, usamos a
      data com getTime e o constructor de String para termos um valor único em
      milisegundos. Adicionalmente, para setarmos o estado de ciclos usamos a
      arrow function chamando o estado atual, pois sua atualização depende dele.
      Podemos salvar a informação do ciclo ativo no próprio ciclo junto as
      demais infos, mas isso geraria uma cadeia de operações na atualização e
      trocas de ciclo muito grandes, já criando um estado novo com o id do ciclo
      ativo nos permite mais agilidade, somente temos que atentar que o valor
      pode ser null pois quando se inicia a aplicação não existe um ciclo ativo.
    </p>

    <h3>Criando countdown</h3>
    <p>
      Criando e manipulando as variáveis necessárias para apresentar o countdown
      em tela.
    </p>

    <h3>O hook useEffect</h3>
    <p>
      useEffect vem de side-effect que significa efeito colateral, ou seja, uma
      ação que ocorre por uma outra ação. Exemplo de adição de um novo item numa
      lista, a ação principal é adicionar o item na lista, mas podemos ter um
      side-effect de avisar uma API que se comunica com um sistema terceiro.
      Podemos fazer isso através de uma função dentro da função de atualização,
      mas isso gera um problema com as clousures do react e não teríamos as
      informações mais atualizadas da lista. Para isso podemos usar o useEffect
      que irá monitorar uma variável e quando alterada irá executar uma função e
      dentro do useEffect os valores da lista já estarão atualizados. Ele
      executa também na primeira vez que o componente é exibido em tela,
      portanto temos que tomar cuidado com essa condição e talvez colocar um
      filtro. Podemos usar o array de dependências do useEffect vazio para que
      ele execute a função apenas 1x na primeira renderização do componente, por
      exemplo buscar dados numa API. Precisamos tomar cuidado também para não
      exagerar no uso do useEffect e fazer atualizações de estado internamente
      dele, gerando uma renderização dupla no código, nestes casos o melhor
      cenário é verificar se o "estado" pode ser convertido em variável e
      simplesmente ser calculada a cada nova renderização.
    </p>

    <h3>Reduzindo o countdown</h3>
    <p>
      Usamos o useEffect para monitorar o ciclo atual e atualizar o countdown
      via função setAmountSecondsPassed e a função differenceInSeconds da
      biblioteca date-fns para contar os segundos que passam mais precisamente.
      Adicionamos no useEffect a variável que estamos monitorando, que é o
      activeCycle, mas isso gera alguns bugs como por exemplo, ter 2 ciclos
      ativos ao mesmo tempo, pois o useEffect será executado sempre que
      atualizarmos o valor do activeCycle. Resolveremos isso na próxima aula.
    </p>
  </body>
</html>

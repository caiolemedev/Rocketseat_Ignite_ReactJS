<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rocketseat - Ignite - ReactJS - Projeto 02 - Anotações</title>
  </head>
  <body>
    <h1>Rocketseat - Ignite - ReactJS - Projeto 02 - Anotações</h1>

    <h2>Estrutura da aplicação</h2>

    <h3>Criação do projeto</h3>
    <p>Criando o projeto usando vite e limpando as configurações padrões.</p>

    <h3>Styled Components</h3>
    <p>
      Entendendo o uso do styled-components no react para estilizar nossos
      componentes. Em vez de utilizarmos class name usamos esta biblioteca para
      que as propriedades passadas pelos pais possam afetar o estilo dos filhos.
      Usamos no exemplo a cor de fundo dos botões.
    </p>

    <h3>Configurando temas</h3>
    <p>
      Podemos usar o gerenciador de temas do styled-components para facilitar a
      aplicação de css e temas específicos através de arquivos na pasta themes
      dentro de styles. Para navegarmos entre os temas basta trocarmos a seleção
      do ThemeProvider em torno dos nossos componentes. Esse gerenciamento pode
      ser feito via um estado que é alterado por um botão específico.
    </p>

    <h3>Tipagem de temas</h3>
    <p>
      Usando o arquivo default.d.ts criamos uma nova interface a partir da
      interface DefaultTheme já existente dentro do styled-components
      adicionando as propriedades que precisamos usar conforme temas criados.
      Com isso conseguimos integrar os temas dentro do nosso projeto fazendo as
      propriedades acessíveis nos arquivos de estilo.
    </p>

    <h3>Estilos globais</h3>
    <p>
      Podemos criar estilos globais usando o styled-components através da função
      createGlobalStyle e inserindo o componete criado chamado GlobalStyles
      dentro do ThemeProvider.
    </p>

    <h3>Cores e Fontes</h3>
    <p>
      Inserindo as fontes via google fonts e cores padrões da aplicação e
      inciando a estilização do tema e dos componentes.
    </p>

    <h3>Configurando ESLint</h3>
    <p>
      EcmaScriptLinting - serve para padronizar o projeto conforme configuração
      do criador do mesmo, substituindo por exemplo aspás duplas por simples e
      vice versa.
    </p>

    <h2>Páginas e rotas</h2>

    <h3>React Router DOM</h3>
    <p>
      Instalando o react-router-dom para estabelecermos a rota dos componentes e
      configurando a aplicação, removendo os botões e acrescentando as páginas
      de Home e History para iniciar o trabalho com rotar através do componente
      Router e do context provider BrowserRouter.
    </p>

    <h3>Layout de rotas</h3>
    <p>
      Acrescentando o header padrão da aplicação via layout e redefinindo as
      rotas para que seja carregado o DefaultLayout em todas as páginas. No
      arquivo de rotas a rota final será a sompatória de todas as rotas
      precedentes, com exemplo admin e admin -> products.
    </p>

    <h3>Header & Layout</h3>
    <p>
      Configurando o layout que é basicamente o fundo preto por volta da
      aplicação via DefaultLayout e também construindo o Header com o logo e
      links necessários. Aplicamos estilização no Header via componente ts
      usando bordas em cima e em baixo para centraliza-lo e também a tag active
      gerada pelo NavLink do react-router-dom para indicar qual página está
      ativa.
    </p>

    <h3>Página: Home</h3>
    <p>
      Adicionando estrutura e estilização na página home usando styled
      components.
    </p>

    <h3>Finalização da Home</h3>
    <p>Finalizando a estilização do formulário, timer e botão.</p>

    <h3>Aprimorando os inputs</h3>
    <p>
      Adicionando configurações no estilo dos inputs como list de sugestões,
      eliminação de features padrão do brownser, etc.
    </p>

    <h3>Página: History</h3>
    <p>
      Adicionando a estrutura básica via tabela da página History e configurando
      o estilo básico.
    </p>

    <h3>Componente: Status</h3>
    <p>
      Desenvolvendo o componente para mostrar o status das tarefas e usando as
      propriedades dos styled components para fazer a mudança de cores quando
      necessário. Usamos uma constante criada para transformarmos os inputs nas
      cores padrão do tema.
    </p>

    <h2>Formulários</h2>

    <h3>Controlled vs Uncontrolled</h3>
    <p>
      Podemos trabalhar com formulários de 2 formas: controlled - o valor do
      input é controlado em tempo real via estado, isso facilita o acesso as
      informações quando fazemos o submit e também para alterar visualmente a
      interface baseado nesse estado; uncontrolled - atualiza o valor do estado
      somente no momento que precisarmos utilizar ela, menos tempo de
      processamento. Controlled para formulários simples, uncontrolled para
      formulários complexos.
    </p>

    <h3>React Hook Form</h3>
    <p>
      Biblioteca para trabalhar com formulários em react usando o melhor dos
      dois mundos (controlled e uncontrolled). Usando o register do
      react-hook-form podemos acoplar em nossos inputs as propriedades para
      validação, controle, etc do conteúdo do input. Para usarmos o handleSubmit
      passamos como parâmetro dela a nossa função handle no formulário. Ainda,
      podemos observar os inputs em tempo real por meio da função watch. Criamos
      uma variável auxiliar para o disabled do botao para facilitar a leitura e
      manutenção do código.
    </p>

    <h3>Validando Formulários</h3>
    <p>
      Biblioteca para fazer validação do formulário, zod. Podemos importar todas
      as funções da biblioteca via * e dar um nome específico quando não existe
      um export default na biblioteca. Para validarmos precisamos passar um
      Schema dos dados via zod object no caso, pois estamos validando um objeto.
      Podemos definir menssagens personalizadas para cada validação.
    </p>

    <h3>TypeScript no formulário</h3>
    <p>
      Podemos definir a interface para o data de forma padrão do TS e usar essa
      definição na validação do formulário para passarmos valores padrões para
      os dados. A integração do zod com o TS permite extrair a tipagem do
      formulário de dentro do Schema de validação usando o infer.
    </p>

    <h3>Resetando formulário</h3>
    <p>
      Podemos trazer da biblioteca zod pela função zodResolver a função reset,
      ela irá resetar o formulário para os valores padrões que setamos como
      defaultValues, basta incluirmos em nossa função handle de submit do
      formulário.
    </p>

    <h2>Funcionalidades da aplicação</h2>

    <h3>Iniciando novo ciclo</h3>
    <p>
      Criamos uma interface de ciclo e um estado de array de ciclos para
      salvarmos as informações inseridas pelos usuários. Para o id, usamos a
      data com getTime e o constructor de String para termos um valor único em
      milisegundos. Adicionalmente, para setarmos o estado de ciclos usamos a
      arrow function chamando o estado atual, pois sua atualização depende dele.
      Podemos salvar a informação do ciclo ativo no próprio ciclo junto as
      demais infos, mas isso geraria uma cadeia de operações na atualização e
      trocas de ciclo muito grandes, já criando um estado novo com o id do ciclo
      ativo nos permite mais agilidade, somente temos que atentar que o valor
      pode ser null pois quando se inicia a aplicação não existe um ciclo ativo.
    </p>

    <h3>Criando countdown</h3>
    <p>
      Criando e manipulando as variáveis necessárias para apresentar o countdown
      em tela.
    </p>

    <h3>O hook useEffect</h3>
    <p>
      useEffect vem de side-effect que significa efeito colateral, ou seja, uma
      ação que ocorre por uma outra ação. Exemplo de adição de um novo item numa
      lista, a ação principal é adicionar o item na lista, mas podemos ter um
      side-effect de avisar uma API que se comunica com um sistema terceiro.
      Podemos fazer isso através de uma função dentro da função de atualização,
      mas isso gera um problema com as clousures do react e não teríamos as
      informações mais atualizadas da lista. Para isso podemos usar o useEffect
      que irá monitorar uma variável e quando alterada irá executar uma função e
      dentro do useEffect os valores da lista já estarão atualizados. Ele
      executa também na primeira vez que o componente é exibido em tela,
      portanto temos que tomar cuidado com essa condição e talvez colocar um
      filtro. Podemos usar o array de dependências do useEffect vazio para que
      ele execute a função apenas 1x na primeira renderização do componente, por
      exemplo buscar dados numa API. Precisamos tomar cuidado também para não
      exagerar no uso do useEffect e fazer atualizações de estado internamente
      dele, gerando uma renderização dupla no código, nestes casos o melhor
      cenário é verificar se o "estado" pode ser convertido em variável e
      simplesmente ser calculada a cada nova renderização.
    </p>

    <h3>Reduzindo o countdown</h3>
    <p>
      Usamos o useEffect para monitorar o ciclo atual e atualizar o countdown
      via função setAmountSecondsPassed e a função differenceInSeconds da
      biblioteca date-fns para contar os segundos que passam mais precisamente.
      Adicionamos no useEffect a variável que estamos monitorando, que é o
      activeCycle, mas isso gera alguns bugs como por exemplo, ter 2 ciclos
      ativos ao mesmo tempo, pois o useEffect será executado sempre que
      atualizarmos o valor do activeCycle. Resolveremos isso na próxima aula.
    </p>

    <h3>Mudando o title da página</h3>
    <p>
      O useEffect permite configurar o seu retorno, que é uma função que permite
      resetar alguma variável ou parâmetro antes de executar o novo useEffect,
      resolvendo assim o bug de dois activeCycle juntos. Precisamos resetar
      também a variável que guarda quantos segundos se passaram quando criamos
      um novo ciclo para que o countdown inicie do valor cheio e não reaproveite
      os segundos passados do ciclo anterior. Inserimos também a função de
      mostrar o countdown no titulo da aba, para o caso de quando usarmos outra
      página enquanto rodamos o ciclo.
    </p>

    <h3>Interromper o ciclo</h3>
    <p>
      Para interromper o ciclo criamos um novo botão para quando temos o ciclo
      ativo e também bloqueamos os inputs. Assim o usuário não pode interir
      nenhum texto quando temos um ciclo ativo. Na sequência criamos a função de
      reset do ciclo usando o map na função setCycles que altera a variável que
      guardamos todas as informações de todos os ciclos para selecionarmos
      somente o ciclo com id igual ao ciclo ativo, os demais são retornados como
      original. Isso respeita a imutabilidade do react. Precisamos também setar
      o valor do ciclo ativo para null, resetando e informando toda a aplicação
      que não existe mais nenhum ciclo ativo.
    </p>

    <h3>Ciclo completo</h3>
    <p>
      No useEffect de atualização do amountSecondsPassed precisamos incluir a
      lógica para salvar a informação do ciclo quando é completado. Para isso
      criamos um if usando a diferença de tempo que se passou contra o total se
      segundos do ciclo até chegarmos no final e salvamos num parâmetro opcional
      a data de finalização. O arco else será executado quando ainda não atingiu
      o total e será reduzido. No if precisamos também zerar a diferença do
      último segundo mostrado e resetar o intervalo.
    </p>

    <h3>Separando componentes</h3>
    <p>
      Aula dedicada a separar os componentes countdown e newcycleform da home
    </p>

    <h3>Prop Drilling no React</h3>
    <p>
      Continuando a separação notamos que informações precisam ser
      compartilhadas entre os componentes e com a home. A comunicação dos
      componentes começa a ficar complexa e de certa forma confusa. Para fazer
      com os componentes se comunicarem normalmente usamos a passagem de
      propriedadesentre eles, mas no caso temos muitas propriedades de
      comunicação que acaba tornando o código somente mais confuso. Mas podemos
      usar outra forma de comunicação entre os componentes que é a Context API,
      que permite compartilhamento de informações entre vários componentes ao
      mesmo tempo, usa uma forma de informações globais e quando modificadas
      independente de quem modificou, atualiza todos os componentes.
    </p>

    <h2>Contexto no React</h2>

    <h3>Etendendo contextos</h3>
    <p>
      A context API é uma maneira de compartilhar as propriedades entre os
      componentes da aplicação. Iniciamos sua aplicação usando a função
      creatContext do react para criar um contexto relacionado às variáveis que
      estamos tratando e setando os seus valores iniciais, normalmente via
      objeto para guardar todas as informações que queremos compartilhar. Para
      compartilhar usamos o hook useContext dentro dos componentes passando o
      nome do contexto que criamos e atribuindo os valores a cada variável. Mas
      quando criamos um contexto com uma informação inicial não conseguimos
      alterar a informação via componentes, mas podemos usar um estado e este
      sim será alterado, mas ele precisa ser criado no componente mais externo
      dos componentes que irão compartilhar a informação. Para que as alterações
      funcionem precisamos adicionar um contexto por volta dos componentes que
      precisam compartilhar a informação, usamos o nome do contexto seguido de
      .Provider e nele setamos os valores desejados como objeto, que se
      sobressaem sobre o valor original do contexto. Para alterar o estado
      dentro dos componentes precisamos passar também a função setVariável
      dentro do objeto do contexto, mas para isso dentro do contexto alteramos o
      objeto para vazio e colocamos o tipo any, assim não temos erro no TS.
      Assim conseguimos acessar a função de set dentro dos componentes para
      alterar o estado e ela será repassada para todos os outros componentes que
      estão usando o mesmo contexto.
    </p>

    <h3>Convertendo para contexto</h3>
    <p>
      Começamos a criar o contexto da aplicação compartilhando o activeCycle e o
      activeCycleId, mas também adicionamos uma nova função
      markCurrentCycleAsFinished. Essa nova função é criada no componente Home
      pois depende da função setCycles que só existe nele, mas é compartilhada
      com os demais componentes. Assim simplificamos a tipagem do nosso contexto
      para uma função que não tem parâmetro e nem retorno.
    </p>

    <h3>Contexto no formulário</h3>
    <p>
      Usamos um contexto específico do react para o form pois precisamos passar
      para o componente NewCycleForm a função register, para isso criamos uma
      variável que irá guardar as funções do newCycleForm na home e
      desestruturamos logo abaixo para podermos usar as funções específicas. No
      provedor de contexto de formulário usamos o spread para adicionarmos as
      propridades do nosso formulário de uma única vez via variável criada. Na
      sequência atualizamos o componente NewCycleForm para importar e utilizar a
      função register.
    </p>

    <h3>Contexto entre rotas</h3>
    <p>
      Não conseguimos acessar o contexto na página do histórico pois estamos
      envolvendo apenas os componentes da Home sendo eles o NewCycleForm e o
      Countdown. Mas a página de histórico também precisa das informações. Para
      resolver este problema criamos um componente de Contexto para prover as
      informações para todas as rotas e colocamos ele por fora das rotas no
      arquivo App. Um ponto importante é que ao fazer isso o Router passar a ser
      uma children do novo componente, isso é uma propriedade particular do
      React que devemos adicionar via interface e desestruturação e incorporar
      no novo componente onde desejamos renderiza-la. Já realizamos a importação
      do contexto na página de histórico também.
    </p>

    <h3>Reset do formulário</h3>
    <p>
      Criamos uma função auxiliar de envio de formulário para incluir o reset na
      função básica de criação de formulário. Assim não alteramos os dados do
      contexto inserindo funções de bibliotecas específicas.
    </p>

    <h3>Listagem do histórico</h3>
    <p>
      Usando os dados compartilhados pelo contexto podemos criar um map dentro
      do histórico para exibir as informações dos ciclos. Para mostrarmos o
      status usamos um if com as informações de interrompido e concluído.
    </p>

    <h3>Formatação de data</h3>
    <p>
      Usando a biblioteca date-fns formatamos a data de início para termos a
      informação de quanto tempo faz que iniciamos o ciclo.
    </p>

    <h2>Reducers</h2>

    <h3>Criando reducers no ciclo</h3>
    <p>
      Usado para armazenar estados mais complexos, similar ao useState. Usado na
      alteração do stado atual quando usamos muitos cálculos ou lógicas
      complexas, nele conseguimos abstrair cada passo do código. No Reducer
      declaramos duas variáveis, uma função que recebe o estado no seu valor
      atual e uma action, que será a ação que será executada em cima do estado,
      e o outro parâmetro é o valor inicial do estado. No lugar de usarmos o
      setVariável usamos o dispatch e passamos duas informações como objeto, uma
      variável (payload) e um valor (type) para a action. Isso fará com que seja
      possível agregar todas as alterações que precisam ser feitas no estado e
      permite seleciona-las via action type.
    </p>

    <h3>Salvando um objeto no Reducer</h3>
    <p>
      Quando temos estados correlacionados podemos passar como primeiro
      parâmetro do useReducer um objeto que contenha as informações deles. Assim
      não precisamos de várias funções e estados para controlar todos eles e
      deixamos tudo compilado no reducer.
    </p>

    <h3>Marcando o ciclo como finalizado</h3>
    <p>
      Aplicamos a mesma lógica do interromper para o finalizar e então trocamos
      todos os if porum único switch.
    </p>

    <h3>Separando Action Types</h3>
    <p>
      Criamos um arquivo de reducers para guardamos as informações da função
      switch com todas as opções. Aproveitamos e fazemos a abstração das opções
      para não termos que usar os textos puros todas as vezes que queremos
      chamar os métodos. Usamos um enum, que é basicamente um dicionário de
      todas as ações que temos disponíveis.
    </p>

    <h3>Separando Actions</h3>
    <p>
      Abstraindo as chamadas das actions restringimos as opções de envio de
      parâmetros no payload, pois a princípio podemos enviar qualquer valor que
      o reducer não irá validar. Assim quando quisermos usar uma das ações basta
      chamar o dispatch executando a função correspondente.
    </p>

    <h3>Utilizando immer</h3>
    <p>
      Usamos a biblioteca immer para podermos usar fórmulas de variáveis
      mutaveis em estados do react, que são imutáveis. Assim simplificamos a
      lógicas das actions retirando os maps dos estados.
    </p>

    <h3>Salvando estado no storage</h3>
    <p>
      Podemos salvar nosso estado no local storage do navegador, mas ele só
      aceita textos, estão usamos o JSON stringfy. Sempre colocar no nome da
      item do local storage com o prefixo do nome da aplicação, pois corremos o
      risco de sobescrevermos o item caso estejamos trabalhando com várias
      aplicações. Adicionar também a versão da informação que estamos salvando
      para limitar os possíveis bugs. Quando recuperamos as informações do local
      storage temos um problema com o formato da data ser uma string, isso
      acontece pois o JSON não aceita nenhum formato além de string e numeros,
      para resolver corrigimos no Countdown colocando um new Date por vonta do
      mostrador. Podemos otimizar o contador para não perdermos 1s durante a
      atualização da página simplesmente setando o amountSecondsPassed através
      de uma função que verificar se existe ou não um ciclo ativo. Caso o
      usuário não tenha nenhuma informação no storage devemos retornar o valor
      do initialState, que é o segundo parâmetro do reducer onde criamos o array
      de ciclos vazio e o activeCycle como null.
    </p>
  </body>
</html>
